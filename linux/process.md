<a href="https://www.google.co.kr/](https://plummmm.tistory.com/211" target="_blank">참고자료</a>

### 프로세스 생성
- fork()이용: 부모는 하나 뿐, 자식은 여러개 가능

### fork()
- Code영억을 제외한 메모리 영역을 복사한다. (Code영역은 공유)
- 그러나 복사는 비효율적 -> Copy-On-Write(COW) 이용
- **COW**: 모든 영역을 공유하고 있다가 둘 중 한 쪽에서 수정하고자 할 때만 page 단위로 복사

### fork() 이후 file descriptor 관리
- fork()하게 되면 동일한 파일 디스크립터를 공유
- 동알한 offset을 공유하고 있으므로 꼬일 확률이 높다
- 따라서 다음과 같은 해결법 사용
1. 부모가 파일에 작업할 내용이 없다면, 자식이 작업을 완료할 때 까지 기다렸다 갱신
2. 둘 다 작업을 해야하는 경우, fork 이후 사용하지 않는 fd를 닫는다(주로 network server)

### vfork() - 부모 프로세스와 자식 프로세스가 모든 것을 공유(복사 X)
- fork()이후 exec()로 다른 프로그램을 실행할 때 사용
- 불필요한 copy를 막는 효과가 있다
- **vfork()이후 자식이 먼저 실행되도록 보장(fork 함수의 경우 자식이 먼저 시작될지 부모가 먼저 시작될지 모름)**

### 프로세스 종료
1. main() function의 return에 의한 종료 -> exit()함수 호출과 동일한 결과
2. exit()함수 호출 -> 할당된 메모리, open file 등을 정리한 뒤 종료
3. _exit(), _Exit() 함수 호출 -> 아무 작업을 하지 않고 커널로 바로 반환
4. abort()호출 - SIGABRT 발생. 현재 상태를 core dump 뜬 다음 비정상 종료
5. 특정 시그널에 의한 종료 - 자기 자신 / 다른 프로세스 / 커널이 보낼 수 있음.(ex. seg. fault는 커널에 의해서 발생하는 시그널)

**(4, 5는 비정상 종료)**</br>
**_exit()은 System Call 함수. 나머지는 라이브러리 함수.**

### 프로세스 상태
1. **좀비 프로세스**: 자식프로세스가 종료되었으나 부모가 아직 종료상태를 회수하지 않은 경우. 정확히 얘기하자면 부모는 wait call을 통해 자식의 종료를 기다리고 있지만, 자식은 이미 종료되어 신호를 보낼 수 없는 상황.
2. **고아 프로세스**: 부모가 자식보다 먼저 종료되는 경우. 이 경우 PID 1번 즉, init 프로세스가 대신 부모가 된다.

일반적으로 프로세스가 종료되면, 커널은 모든 활성 프로세스를 탐색하여 고아 프로세스가 있는지 확인. 또한, init 프로세스는 자식 프로세스 중 하나가 종료되면 wait()류 함수를 호출하여 종료상태를 회수하므로 좀비 프로세스가 되지 않는다.

### 프로세스 종료 상태 회수
wait류 함수 - 부모가 자식이 종료될 때 까지 기다리게 하고, 종료 상태를 회수할 때 쓰는 함수.
- 자식이 종료되면 커널이 부모에게 SIGCHLD 시그널을 보낸다. 보통은 이 시그널을 무시하지만, 자식 종료를 기다리려면 wait()함수를 등록해 해당 시그널을 처리하도록 하는 것.

## 리눅스 프로세스 구조
1. 터미널을 켠다 -> init 프로세스가 fork().
2. exec()로 fork된 프로세스를 getty라는 프로그램으로 변경(getty: 터미널 관리 프로그램) **현재 상황: init - getty**
