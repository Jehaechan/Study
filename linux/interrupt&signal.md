https://getchan.github.io/cs/OS_1/
### kernel?
메모리에 상주하는 운영체제의 부분

#### 입출력 관리
- 주변 장치들은 CPU의 서비스가 필요한 경우 interrupt를 발생시켜 서비스를 요청
- CPU는 주어진 작업을 실행하다 인터럽트가 발생하면 하던 일을 멈추고 인터럽트에 의한 요청 서비스를 수행
- 인터럽트 서비스가 끝나면 원래 하던 일을 계속 수행 - 이를 위해 수행중이던 작업의 상태를 저장해 둔다.
- 인터럽트 처리 루틴: 인터럽트가 발생했을 때 해야 할 작업이 정의된 프로그램 코드. 운영체제 커널 내에 존재
- 주변 장치들은 장치마다 연산 유닛(CPU)를 가지고 있다. 이를 컨트롤러라 한다. 컨트롤러는 해당 주변 장치의 업무를 처리하고, 메인 CPU에 인터럽트를 발생시킨다.

#### 프로그램 구조
프로그램은 함수로 구성. 함수 실행 중에 다른 함수를 호출. 호출된 함수의 수행이 끝나면 원래 함수로 돌아가 계속 수행. 프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다.</br?
프로그램 주소 영역 - **코드/데이터/스택**

### Interrupt란?
- 동작 원리
    1. A프로그램이 CPU를 할당 받아 수행 중 인터럽트 발생
    2. A는 현재 수행중인 명령의 위치를 저장
    3. OS내부 인터럽트 처리 루틴으로 들어가 처리
    4. A의 작업 지점부터 다시 수행
- 일반적으로 프로그램 내에서 함수 호출에 필요한 복귀 주소는 각 프로그램의 stack 영역에 보관(현재 PC를 스택에 푸쉬 해놓고 복귀할 때 pop해서 확인)
- 반면, 인터럽트 때문에 CPU를 선점 당해(kernel mode) 돌아올 곳을 저장하는 복귀 주소는 OS kernel 영역에 존재 -> PCB에 저장하게 된다.

### Computer System
CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터 -> PC </br>
- **Hardware**
    - CPU
        - 일반 명령: 모든 프로그램이 수행 가능 (mode bit == 1)
        - 특권 명령: 보안이 필요한 명령 (mode bit == 0)
    - memory
        - kernel mode: PC가 kernel code가 존재하는 메모리를 가리키고 있다
        - user mode: PC가 사용자 프로그램이 존재하는 메모리를 가리키고 있다
    - I/O Device
        - I/O Controller(CPU)
        - Local Buffer
사용자 프로그램이 특권 명령의 수행을 필요로 하면, OS에게 특권 명령의 대행을 요청 -> System Call!
ex) 디스크에서 자료를 읽어오는 System Call을 하게 되면
    1. System Call
    2. CPU가 컨트롤 레지스터를 세팅해 디스크 컨트롤러에게 데이터를 읽어오라는 명령을 내림
    3. 디스크 컨트롤러는 디스크로부터 데이터를 읽어와 자신의 로컬 버퍼에 저장
    4. 디스크 컨트롤러가 CPU에게 HW Interrupt 발생</br>
    **주변 장치 Interrupt line을 설정 -> CPU는 매번 명령을 시행한 직후 interrupt line을 체크 -> Interrupt가 발생하면 CPU는 해당 인터럽트 루틴으로 넘어가 이를 처리**

### OS memory space
- **Code 영역**
    - CPU, Memory 등 자원관리를 위한 부분
    - 사용자에게 편리한 인터페이스를 제공하기 위한 부분
    - System Call, Interrupt 처리하는 부분
- **Data 영역 - 각종 자원을 관리하기 위한 자료구조 저장**
    - CPU, Memory와 같은 하드웨어 자원 관리
    - 현재 수행중인 프로세스 관리 -> PCB
        - 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지
- **Stack 영역 - 함수 호출 시의 복귀 주소를 저장하기 위한 용도로 사용**
    - 유저 프로그램의 스택과 달리 현재 수행중인 프로세스마다 별도의 스택을 두어 관리
    - 프로세스가 System Call 후 System Call 내부에서 다른 함수를 호출하는 경우 복귀 주소는 커널 내의 주소가 되어 유저 프로그램의 스택과는 별도의 저장 공간이 필요
    - 커널은 일종의 공유 코드이므로 일관성 유지를 위해 각 프로세스마다 커널 내 별도의 스택이 필요
![image](https://user-images.githubusercontent.com/71350045/231543605-0355df1f-d849-423e-b3ea-f3d11f145b52.png)


https://sptinspot.tistory.com/24
#### Mode bit
Mode bit를 통해 하드웨어적으로 두 가지 모드의 operation을 지원. User mode -> 제한된 instruction. Kernel mode -> OS 코드를 수행. </br>
Interrupt나 Exception 발생 시 하드웨어가 mode bit을 0으로 바꾸고, 사용자 프로그램으로 CPU를 넘기기 전에 mode bit을 다시 1로 setting한다.

### Signal이란?
유저 레벨(OS 레벨 X)에서의 인터럽트. 시그널은 asynchronous(언제 들어올지 모르는) urgent event를 다룬다.</br>
프로세스는 interrupt가 들어와서 kernel mode로 trap한 후 할 일을 마치고 user mode
### 유저 프로세스 입장에서의 시그널
실행 흐름을 제어하는 비동기적인 중단.
#### 정규 시그널 vs 리얼 타임 시그널
- 정규 시그널: 같은 종류의 시그널을 연달아 보내면 프로세스는 한 가지 시그널만 받아서 처리
- 리얼 타임 시그널: 모두 큐에 쌓아서 처리
#### 시그널 발생시키는 방법
1. kill(), tgkill()과 같은 리눅스 저수준 표준 함수를 호출하여 시그널 발생
2. 리눅스 터미널에서 kill 명령어로 시그널 발생
3. 커널이 스스로 시그널을 발생시켜야 한다고 판단할 때 ex) 프로세스가 종료될 때 부모 프로세스에게 자식 프로세스가 종료된다는 정보를 SIGCHLD 시그널로 알림



### 커널에서의 Signal
커널은 시그널 자료 구조를 업데이트해 시그널을 생성하고 전달해주는 중재자 역할을 한다. **커널 입장에서 시그널이란 프로세스 간 통신을 위한 간단한 인터페이스**

#### 커널의 시그널 처리 과정
1. 시그널 생성</br>
    1. 시그널을 받을 프로세스에게 시그널 정보를 써준다. (struct thread_info 구조체 flags 필드에 \_TIF_SIGPENDING 플래그를 저장) -> 시그널을 받을 프로세스를 깨운다.(2 Step)
    2. wake_up_process() 함수를 호출하여 시그널을 받을 프로세스를 깨운다.
2. 시그널을 받아 처리</br>
    1. 시그널을 받을 프로세스는 시스템 콜이나 인터럽트 처리를 마무리한 후 시그널을 받아 처리.
    2. 커널은 시그널 종류에 따라 유저 프로세스가 정해진 동작을 수행하도록 지원해주는 중재자 역할을 수행. 그러나 조건에 따라 2가지 다른 동작을 수행.
        - **유저 어플리케이션에서 시그널 핸들러를 설정했을 경우**: 커널은 시그널 핸들러를 호출만 해주고(유저 어플리케이션에서 지정한 시그널 핸들러 주소를 PC에 써준다), 시그널 종류에 따라 세부적인 처리를 할 수 없음.
        - **유저 어플리케이션에서 시그널 핸들러를 설정하지 않았을 경우**: 커널이 중재자 역할에만 그치지 않고 시그널 타입에 따라 프로세스를 처리 (ex. SIGINT, SIGKILL -> 프로세스 종료)
       
