https://getchan.github.io/cs/OS_1/
### kernel?
메모리에 상주하는 운영체제의 부분

#### 입출력 관리
- 주변 장치들은 CPU의 서비스가 필요한 경우 interrupt를 발생시켜 서비스를 요청
- CPU는 주어진 작업을 실행하다 인터럽트가 발생하면 하던 일을 멈추고 인터럽트에 의한 요청 서비스를 수행
- 인터럽트 서비스가 끝나면 원래 하던 일을 계속 수행 - 이를 위해 수행중이던 작업의 상태를 저장해 둔다.
- 인터럽트 처리 루틴: 인터럽트가 발생했을 때 해야 할 작업이 정의된 프로그램 코드. 운영체제 커널 내에 존재
- 주변 장치들은 장치마다 연산 유닛(CPU)를 가지고 있다. 이를 컨트롤러라 한다. 컨트롤러는 해당 주변 장치의 업무를 처리하고, 메인 CPU에 인터럽트를 발생시킨다.

#### 프로그램 구조
프로그램은 함수로 구성. 함수 실행 중에 다른 함수를 호출. 호출된 함수의 수행이 끝나면 원래 함수로 돌아가 계속 수행. 프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다.</br?
프로그램 주소 영역 - **코드/데이터/스택**

### Interrupt란?
- 동작 원리
    1. A프로그램이 CPU를 할당 받아 수행 중 인터럽트 발생
    2. A는 현재 수행중인 명령의 위치를 저장
    3. OS내부 인터럽트 처리 루틴으로 들어가 처리
    4. A의 작업 지점부터 다시 수행
- 일반적으로 프로그램 내에서 함수 호출에 필요한 복귀 주소는 각 프로그램의 stack 영역에 보관(현재 PC를 스택에 푸쉬 해놓고 복귀할 때 pop해서 확인)
- 반면, 인터럽트 때문에 CPU를 선점 당해(kernel mode) 돌아올 곳을 저장하는 복귀 주소는 OS kernel 영역에 존재 -> PCB에 저장하게 된다.
- 

### Signal이란?
유저 레벨(OS 레벨 X)에서의 인터럽트. 시그널은 asynchronous(언제 들어올지 모르는) urgent event를 다룬다.</br>
프로세스는 interrupt가 들어와서 kernel mode로 trap한 후 할 일을 마치고 user mode
### 유저 프로세스 입장에서의 시그널
실행 흐름을 제어하는 비동기적인 중단.
#### 정규 시그널 vs 리얼 타임 시그널
- 정규 시그널: 같은 종류의 시그널을 연달아 보내면 프로세스는 한 가지 시그널만 받아서 처리
- 리얼 타임 시그널: 모두 큐에 쌓아서 처리
#### 시그널 발생시키는 방법
1. kill(), tgkill()과 같은 리눅스 저수준 표준 함수를 호출하여 시그널 발생
2. 리눅스 터미널에서 kill 명령어로 시그널 발생
3. 커널이 스스로 시그널을 발생시켜야 한다고 판단할 때 ex) 프로세스가 종료될 때 부모 프로세스에게 자식 프로세스가 종료된다는 정보를 SIGCHLD 시그널로 알림



### 커널에서의 Signal
커널은 시그널 자료 구조를 업데이트해 시그널을 생성하고 전달해주는 중재자 역할을 한다. **커널 입장에서 시그널이란 프로세스 간 통신을 위한 간단한 인터페이스**

#### 커널의 시그널 처리 과정
1. 시그널 생성</br>
    1. 시그널을 받을 프로세스에게 시그널 정보를 써준다. (struct thread_info 구조체 flags 필드에 \_TIF_SIGPENDING 플래그를 저장) -> 시그널을 받을 프로세스를 깨운다.(2 Step)
    2. wake_up_process() 함수를 호출하여 시그널을 받을 프로세스를 깨운다.
2. 시그널을 받아 처리</br>
    1. 시그널을 받을 프로세스는 시스템 콜이나 인터럽트 처리를 마무리한 후 시그널을 받아 처리.
    2. 커널은 시그널 종류에 따라 유저 프로세스가 정해진 동작을 수행하도록 지원해주는 중재자 역할을 수행. 그러나 조건에 따라 2가지 다른 동작을 수행.
        - **유저 어플리케이션에서 시그널 핸들러를 설정했을 경우**: 커널은 시그널 핸들러를 호출만 해주고(유저 어플리케이션에서 지정한 시그널 핸들러 주소를 PC에 써준다), 시그널 종류에 따라 세부적인 처리를 할 수 없음.
        - **유저 어플리케이션에서 시그널 핸들러를 설정하지 않았을 경우**: 커널이 중재자 역할에만 그치지 않고 시그널 타입에 따라 프로세스를 처리 (ex. SIGINT, SIGKILL -> 프로세스 종료)
       
